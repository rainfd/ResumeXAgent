# Story 6.5: 开发 AI 批量岗位智能推荐

## Status

Draft

## Story

**As a** 用户，
**I want** AI 帮我分析多个岗位并推荐最佳选择，
**so that** 提高求职效率

## Acceptance Criteria

1. AI 同时分析多个岗位的匹配度
2. 基于多维度考虑推荐投递优先级
3. 识别最有潜力的机会
4. 分析不同岗位的共性和差异
5. 为每个岗位定制简历版本建议
6. 生成批量投递策略建议

## Tasks / Subtasks

- [ ] Task 1: 创建批量岗位分析器 (AC: 1)
  - [ ] 创建 `lib/analyzers/batch-job-analyzer.ts` 批量岗位分析器
  - [ ] 实现多岗位并行分析处理架构
  - [ ] 开发岗位数据标准化和清洗功能
  - [ ] 集成 AI 服务进行并行匹配度计算
  - [ ] 添加分析进度跟踪和错误恢复机制
  - [ ] 实现分析结果的聚合和排序功能

- [ ] Task 2: 构建多维度推荐引擎 (AC: 2)
  - [ ] 创建 `lib/engines/multi-dimensional-recommendation.engine.ts` 多维度推荐引擎
  - [ ] 实现基于匹配度、薪资、地理位置的综合评分
  - [ ] 开发用户偏好权重配置系统
  - [ ] 添加市场热度和行业趋势分析
  - [ ] 实现动态权重调整和学习算法
  - [ ] 集成风险评估和稳定性分析

- [ ] Task 3: 开发潜力机会识别器 (AC: 3)
  - [ ] 创建 `lib/detectors/opportunity-detector.ts` 潜力机会识别器
  - [ ] 实现基于成长潜力的机会识别算法
  - [ ] 开发隐藏价值和未来发展空间分析
  - [ ] 添加行业发展趋势和公司前景评估
  - [ ] 实现个人职业路径匹配度分析
  - [ ] 集成薪资增长潜力和职业发展机会评估

- [ ] Task 4: 构建岗位对比分析器 (AC: 4)
  - [ ] 创建 `lib/analyzers/job-comparison.analyzer.ts` 岗位对比分析器
  - [ ] 实现岗位间的多维度相似性分析
  - [ ] 开发共性和差异的结构化提取
  - [ ] 添加岗位聚类和分组功能
  - [ ] 实现竞争激烈程度和难易度评估
  - [ ] 集成岗位特征向量化和相似度计算

- [ ] Task 5: 开发简历定制化建议器 (AC: 5)
  - [ ] 创建 `lib/customizers/resume-customizer.ts` 简历定制化建议器
  - [ ] 实现针对不同岗位的简历优化策略
  - [ ] 开发关键词密度和内容重点调整建议
  - [ ] 添加技能强调和经验排序优化
  - [ ] 实现多版本简历生成和管理
  - [ ] 集成 A/B 测试建议和效果预测

- [ ] Task 6: 构建批量投递策略顾问 (AC: 6)
  - [ ] 创建 `lib/advisors/batch-application-strategy.advisor.ts` 批量投递策略顾问
  - [ ] 实现最优投递时间和频率建议
  - [ ] 开发投递渠道优化和分配策略
  - [ ] 添加跟进计划和沟通时间表生成
  - [ ] 实现风险分散和成功率最大化策略
  - [ ] 集成投递效果跟踪和策略调整机制

- [ ] Task 7: 创建批量推荐UI组件 (AC: 1-6)
  - [ ] 创建 `components/recommendations/batch-job-recommender.tsx` 批量推荐主组件
  - [ ] 实现基于 React + shadcn/ui 的岗位对比可视化
  - [ ] 开发交互式岗位筛选和排序界面
  - [ ] 添加推荐理由和详细分析展示面板
  - [ ] 实现简历定制预览和批量操作界面
  - [ ] 集成投递策略规划和执行跟踪工具

- [ ] Task 8: 集成批量推荐API (AC: 1-6)
  - [ ] 创建 `app/api/recommendations/batch/route.ts` 批量推荐API
  - [ ] 实现基于 Next.js API Routes 的批量分析接口
  - [ ] 集成所有推荐组件的协调和数据流
  - [ ] 添加批量操作的异步处理和队列管理
  - [ ] 实现推荐结果的缓存和增量更新
  - [ ] 集成用户反馈收集和推荐算法优化

- [ ] Task 9: 开发测试套件 (所有 AC)
  - [ ] 创建 `tests/e2e/batch-job-recommendation.spec.ts` 端到端测试
  - [ ] 测试大量岗位数据的处理性能和准确性
  - [ ] 验证推荐算法的一致性和可靠性
  - [ ] 测试并发处理和错误恢复机制
  - [ ] 创建不同规模和类型的岗位测试数据集

## Dev Notes

### Previous Story Insights

从 Epic 6 前置故事依赖分析：
- **Story 6.1-6.3**: 提供单一岗位分析的基础能力，为批量分析提供核心算法
- **Story 6.4**: 提供综合报告生成能力，为批量推荐结果展示提供基础
- **依赖策略**: 本故事需要扩展前置故事的分析能力到批量处理场景
- **架构考虑**: 需要处理高并发分析请求和大数据量处理

### 技术栈要求 [Source: architecture/技术栈.md]

- **AI服务**: OpenRouter API (并行多岗位分析) + DeepSeek API (中文岗位理解优化)
- **数据库**: SQLite 3.45.0 + better-sqlite3 9.4.0 (批量分析结果存储)
- **类型系统**: TypeScript 5.3.3 (严格类型检查)
- **UI框架**: React 18.3.0 + shadcn/ui (批量推荐界面)
- **HTTP客户端**: axios 1.6.0 (AI API并发调用)
- **队列处理**: 需要集成任务队列系统处理批量异步任务

### AI 批量岗位推荐架构设计 [Source: architecture/组件.md]

**AI 批量岗位推荐服务接口:**

```typescript
interface BatchJobRecommendationEngine {
  analyzeBatchJobs(jobs: Job[], userProfile: UserProfile): Promise<BatchAnalysisResult>;
  generateRecommendations(analysisResult: BatchAnalysisResult, preferences: UserPreferences): Promise<JobRecommendationSet>;
  compareJobs(jobs: Job[], comparisonCriteria: ComparisonCriteria): Promise<JobComparison>;
  identifyOpportunities(analysisResult: BatchAnalysisResult, marketContext: MarketContext): Promise<OpportunityInsight[]>;
  customizeResumeStrategies(jobs: Job[], resume: Resume): Promise<ResumeCustomizationPlan[]>;
  generateApplicationStrategy(recommendations: JobRecommendationSet): Promise<ApplicationStrategy>;
}

interface BatchAnalysisResult {
  analysis_id: string;
  user_id: string;
  job_count: number;
  analysis_timestamp: Date;
  processing_duration: number;
  
  // 批量分析核心结果
  individual_job_analyses: IndividualJobAnalysis[];
  comparative_insights: ComparativeInsight[];
  cluster_analysis: JobClusterAnalysis;
  market_positioning: MarketPositioning;
  
  // 质量和可信度指标
  analysis_confidence: number;
  data_quality_scores: DataQualityScore[];
  processing_statistics: ProcessingStatistics;
}

interface JobRecommendationSet {
  recommendation_id: string;
  generation_timestamp: Date;
  total_jobs_analyzed: number;
  
  // 推荐分层结构
  tier_1_recommendations: TopTierRecommendation[];    // 强烈推荐 (前20%)
  tier_2_recommendations: StandardRecommendation[];   // 标准推荐 (20-60%)
  tier_3_recommendations: ConsiderationOption[];      // 考虑选项 (60-100%)
  
  // 推荐元数据
  recommendation_reasoning: RecommendationReasoning[];
  risk_assessment: RiskAssessment[];
  opportunity_scoring: OpportunityScoring[];
  diversification_analysis: DiversificationAnalysis;
}

interface JobComparison {
  comparison_id: string;
  jobs_compared: Job[];
  comparison_matrix: ComparisonMatrix;
  
  // 多维度对比
  skill_requirement_comparison: SkillRequirementComparison;
  experience_level_comparison: ExperienceLevelComparison;
  compensation_analysis: CompensationAnalysis;
  growth_potential_comparison: GrowthPotentialComparison;
  
  // 分组和聚类
  job_clusters: JobCluster[];
  similarity_networks: SimilarityNetwork[];
  outlier_identification: OutlierJob[];
}

interface OpportunityInsight {
  opportunity_type: 'high_growth' | 'hidden_gem' | 'perfect_match' | 'stretch_goal' | 'backup_option';
  job_id: string;
  opportunity_score: number; // 0-100
  
  // 机会分析
  growth_indicators: GrowthIndicator[];
  competitive_advantage: CompetitiveAdvantage[];
  risk_factors: RiskFactor[];
  timing_considerations: TimingConsideration[];
  
  // 行动建议
  recommended_actions: RecommendedAction[];
  preparation_timeline: PreparationTimeline;
  success_probability: number;
}
```

### 批量处理核心算法

**1. 高效批量分析算法:**

```typescript
interface BatchProcessingEngine {
  processBatchAnalysis(
    jobs: Job[],
    userProfile: UserProfile,
    processingOptions: ProcessingOptions
  ): Promise<BatchAnalysisResult>;
  
  optimizeBatchSize(
    totalJobs: number,
    resourceConstraints: ResourceConstraints
  ): BatchConfiguration;
  
  handleBatchFailures(
    failedJobs: Job[],
    errorContext: ErrorContext
  ): Promise<RecoveryResult>;
}

// 智能批量处理算法
const processBatchJobAnalysis = async (
  jobs: Job[],
  userProfile: UserProfile,
  options: BatchProcessingOptions
): Promise<BatchAnalysisResult> => {
  // 1. 批次规划和优化
  const batchConfig = optimizeBatchConfiguration(jobs.length, options.resourceLimits);
  
  // 2. 数据预处理和标准化
  const preprocessedJobs = await preprocessJobData(jobs);
  
  // 3. 并行分析执行
  const analysisPromises = preprocessedJobs.map(batch => 
    processBatchChunk(batch, userProfile, batchConfig)
  );
  
  // 4. 结果聚合和后处理
  const rawResults = await Promise.allSettled(analysisPromises);
  const aggregatedResults = aggregateBatchResults(rawResults);
  
  // 5. 质量评估和验证
  const qualityMetrics = assessAnalysisQuality(aggregatedResults);
  
  // 6. 智能重试和错误恢复
  const finalResults = await handleFailuresAndRetry(aggregatedResults, qualityMetrics);
  
  return {
    individual_analyses: finalResults,
    processing_metadata: batchConfig,
    quality_scores: qualityMetrics,
    performance_statistics: calculatePerformanceStats(rawResults)
  };
};
```

**2. 多维度推荐排序算法:**

```typescript
interface MultiDimensionalRankingEngine {
  calculateCompositeScore(
    jobAnalysis: IndividualJobAnalysis,
    userPreferences: UserPreferences,
    marketFactors: MarketFactors
  ): CompositeScore;
  
  optimizeRecommendationDiversity(
    candidateJobs: ScoredJob[],
    diversityConstraints: DiversityConstraints
  ): DiversifiedRecommendationSet;
}

// 多维度综合评分算法
const calculateJobRecommendationScore = async (
  jobAnalysis: IndividualJobAnalysis,
  userProfile: UserProfile,
  marketContext: MarketContext
): Promise<ComprehensiveJobScore> => {
  // 1. 基础匹配评分
  const baseMatchScore = calculateBaseMatchScore(jobAnalysis, userProfile);
  
  // 2. 市场因素调整
  const marketAdjustedScore = applyMarketFactors(baseMatchScore, marketContext);
  
  // 3. 个人偏好权重应用
  const preferenceWeightedScore = applyUserPreferences(
    marketAdjustedScore,
    userProfile.jobPreferences
  );
  
  // 4. 风险和机会平衡
  const riskAdjustedScore = balanceRiskAndOpportunity(
    preferenceWeightedScore,
    jobAnalysis.riskFactors
  );
  
  // 5. 时间敏感性考虑
  const timeSensitiveScore = applyTimingSensitivity(
    riskAdjustedScore,
    jobAnalysis.applicationDeadline,
    marketContext.urgencyFactors
  );
  
  // 6. 组合优化考虑
  const portfolioOptimizedScore = optimizeForPortfolio(
    timeSensitiveScore,
    userProfile.applicationStrategy
  );
  
  return {
    composite_score: portfolioOptimizedScore,
    score_breakdown: {
      base_match: baseMatchScore,
      market_factors: marketAdjustedScore - baseMatchScore,
      user_preferences: preferenceWeightedScore - marketAdjustedScore,
      risk_adjustment: riskAdjustedScore - preferenceWeightedScore,
      timing_factor: timeSensitiveScore - riskAdjustedScore,
      portfolio_optimization: portfolioOptimizedScore - timeSensitiveScore
    },
    confidence_interval: calculateScoreConfidence(portfolioOptimizedScore),
    sensitivity_analysis: performSensitivityAnalysis(portfolioOptimizedScore)
  };
};
```

**3. 智能岗位聚类和对比算法:**

```typescript
interface JobClusteringEngine {
  clusterJobsBysimilarity(
    jobs: Job[],
    clusteringCriteria: ClusteringCriteria
  ): JobClusterResult[];
  
  identifyJobPatterns(
    jobClusters: JobClusterResult[],
    userProfile: UserProfile
  ): JobPatternInsight[];
  
  generateComparisonMatrix(
    jobs: Job[],
    comparisonDimensions: ComparisonDimension[]
  ): ComparisonMatrix;
}

// 智能岗位聚类分析
const performJobClusterAnalysis = async (
  jobs: Job[],
  userProfile: UserProfile
): Promise<JobClusteringResult> => {
  // 1. 特征向量提取
  const jobFeatures = await extractJobFeatureVectors(jobs);
  
  // 2. 相似度计算
  const similarityMatrix = calculateJobSimilarity(jobFeatures);
  
  // 3. 智能聚类
  const clusters = performAdaptiveClustering(
    similarityMatrix,
    userProfile.preferences.clusteringPreference
  );
  
  // 4. 聚类质量评估
  const clusterQuality = assessClusteringQuality(clusters, similarityMatrix);
  
  // 5. 聚类解释生成
  const clusterExplanations = generateClusterExplanations(clusters, jobFeatures);
  
  // 6. 用户导向的聚类优化
  const optimizedClusters = optimizeForUserRelevance(clusters, userProfile);
  
  return {
    job_clusters: optimizedClusters,
    similarity_matrix: similarityMatrix,
    cluster_explanations: clusterExplanations,
    quality_metrics: clusterQuality,
    user_relevance_scores: calculateUserRelevanceScores(optimizedClusters, userProfile)
  };
};
```

### AI提示词策略 [Source: architecture/外部api.md]

**批量岗位推荐分析提示词模板:**

```
请对多个岗位进行智能分析和推荐排序：

=== 批量岗位数据 ===
岗位总数：{total_job_count}
岗位详情列表：{job_details_list}
用户简历信息：{user_resume}
用户求职偏好：{job_preferences}
市场背景信息：{market_context}

=== 分析要求 ===

1. 批量匹配度分析
   - 对每个岗位进行全面的匹配度评估
   - 计算技能、经验、教育背景的匹配程度
   - 识别每个岗位的独特要求和挑战
   - 评估候选人在每个岗位的竞争力

2. 多维度推荐排序
   - 综合考虑匹配度、薪资水平、发展潜力、工作环境等因素
   - 基于用户偏好权重进行个性化排序
   - 考虑地理位置、行业稳定性、公司前景等外部因素
   - 平衡风险和机会，避免过度集中或分散

3. 潜力机会识别
   - 识别高成长潜力但竞争相对较小的机会
   - 发现可能被忽视但高度匹配的岗位
   - 分析行业发展趋势和职业路径机会
   - 评估每个机会的时间窗口和准备要求

4. 岗位对比分析
   - 分析不同岗位间的相似性和差异性
   - 识别岗位聚类和分组模式
   - 比较薪资待遇、工作要求、发展前景
   - 分析投递策略的多样性和风险分散效果

5. 简历定制建议
   - 为每个岗位类型提供简历优化方向
   - 建议关键词密度调整和内容重点变化
   - 推荐技能突出和经验排序策略
   - 提供多版本简历管理建议

6. 批量投递策略
   - 制定最优的投递时间表和顺序
   - 建议不同渠道的投递分配比例
   - 设计跟进计划和沟通策略
   - 提供风险管控和成功率优化建议

=== 输出格式要求 ===

请提供结构化的JSON格式分析结果，包括：

分层推荐结果：
- 第一梯队：强烈推荐岗位 (匹配度>85%)
- 第二梯队：标准推荐岗位 (匹配度60-85%)  
- 第三梯队：考虑备选岗位 (匹配度40-60%)

每个岗位包含：
- 综合评分和排序理由
- 匹配度详细分解
- 机会和风险评估
- 简历定制要点
- 投递策略建议

整体策略建议：
- 投递优先级和时间安排
- 风险分散和成功率优化
- 备选方案和应急计划

分析语言：中文
推荐风格：{recommendation_style}
风险偏好：{risk_preference}
重点关注：{focus_priorities}
```

### 数据模型扩展 [Source: architecture/数据模型.md]

**新增批量推荐相关数据存储:**

```typescript
interface BatchJobRecommendationRecord {
  id: string;
  user_id: string;
  job_ids: string[];
  analysis_result: BatchAnalysisResult;
  recommendation_set: JobRecommendationSet;
  user_interactions: UserInteractionRecord[];
  application_tracking: ApplicationTrackingRecord[];
  performance_metrics: RecommendationPerformanceMetric[];
  created_at: Date;
  updated_at: Date;
}

interface JobClusterDefinition {
  cluster_id: string;
  cluster_name: string;
  cluster_description: string;
  defining_characteristics: string[];
  job_ids_in_cluster: string[];
  cluster_centroid: JobFeatureVector;
  cluster_quality_score: number;
  user_relevance_score: number;
}

interface ApplicationStrategy {
  strategy_id: string;
  user_id: string;
  target_application_count: number;
  timeline: ApplicationTimeline;
  channel_distribution: ChannelDistribution[];
  risk_management: RiskManagementPlan;
  success_metrics: SuccessMetric[];
  adaptation_triggers: AdaptationTrigger[];
}

interface RecommendationFeedbackLoop {
  feedback_id: string;
  recommendation_id: string;
  user_id: string;
  feedback_type: 'application_result' | 'user_rating' | 'strategy_adjustment';
  feedback_data: FeedbackData;
  impact_on_future_recommendations: ImpactAssessment;
  learning_weight: number;
  timestamp: Date;
}
```

### 项目结构要求 [Source: architecture/源代码树.md]

**批量推荐相关文件:**

```
lib/analyzers/
├── batch-job-analyzer.ts               # 批量岗位分析器
├── job-comparison.analyzer.ts          # 岗位对比分析器
└── market-trend.analyzer.ts            # 市场趋势分析器

lib/engines/
├── multi-dimensional-recommendation.engine.ts  # 多维度推荐引擎
├── job-clustering.engine.ts                   # 岗位聚类引擎
└── batch-processing.engine.ts                 # 批量处理引擎

lib/detectors/
├── opportunity-detector.ts             # 潜力机会识别器
└── pattern-detector.ts                # 模式识别器

lib/customizers/
├── resume-customizer.ts               # 简历定制器
└── application-strategy-customizer.ts  # 申请策略定制器

lib/advisors/
├── batch-application-strategy.advisor.ts  # 批量申请策略顾问
└── portfolio-optimization.advisor.ts      # 组合优化顾问

lib/processors/
├── concurrent-processor.ts            # 并发处理器
├── queue-manager.ts                   # 队列管理器
└── error-recovery.processor.ts        # 错误恢复处理器

lib/types/
├── batch-recommendation.types.ts      # 批量推荐类型定义
├── job-clustering.types.ts           # 岗位聚类类型定义
└── strategy-optimization.types.ts     # 策略优化类型定义

components/recommendations/
├── batch-job-recommender.tsx          # 批量推荐主组件
├── job-comparison-matrix.tsx          # 岗位对比矩阵
├── opportunity-insights.tsx           # 机会洞察面板
├── clustering-visualization.tsx       # 聚类可视化
├── strategy-planner.tsx              # 策略规划器
└── recommendation-dashboard.tsx       # 推荐仪表板

app/api/recommendations/
├── batch/route.ts                     # 批量推荐API
├── comparison/route.ts                # 岗位对比API
├── clustering/route.ts                # 聚类分析API
└── strategy/route.ts                  # 策略规划API
```

### 性能和用户体验要求

**批量处理性能:**
- 单批次(10个岗位)分析时间 < 30秒
- 大批量(50个岗位)分析时间 < 2分钟
- 推荐结果生成时间 < 8秒
- 对比分析响应时间 < 5秒
- 支持最大100个岗位的并发分析

**用户体验:**
- 实时进度展示和状态更新
- 交互式岗位对比和筛选
- 可视化聚类和相似性展示
- 个性化推荐理由说明
- 便捷的批量操作和管理

### 商业价值和实用性

**求职效率提升:**
1. **智能筛选**: 从海量岗位中快速识别最佳机会
2. **策略优化**: 最大化投递成功率和时间效率
3. **风险管理**: 平衡高风险高收益和稳妥选择
4. **个性化**: 基于个人特征的深度定制推荐

### Testing Requirements [Source: architecture/测试策略和标准.md]

**测试数据准备:**
- 大规模岗位数据集(10-100个岗位的不同组合)
- 不同行业和职位层级的岗位多样性测试
- 并发处理压力测试数据
- 推荐算法准确性验证数据集

**测试指标:**
- 批量处理成功率 (>98%)
- 推荐排序准确性 (>82%)
- 机会识别准确率 (>78%)
- 系统并发处理能力 (支持20个并发用户)
- 用户满意度评价 (>88%)

### 安全和隐私考虑 [Source: architecture/安全.md]

**批量数据安全:**
- 大量岗位数据的安全传输和存储
- 用户投递策略的隐私保护
- 推荐算法的公平性和透明度
- 批量操作的审计日志和追踪
- 数据处理的合规性保证

## Change Log

| Date       | Version | Description                        | Author       |
| ---------- | ------- | ---------------------------------- | ------------ |
| 2025-08-09 | 1.0     | 初始故事创建，基于Epic 6.5要求     | Scrum Master |

## Dev Agent Record

### Agent Model Used

待实现

### Debug Log References

待实现

### Completion Notes List

待实现

### File List

待实现

## QA Results

### Review Date

待审查

### Reviewed By

待指定